Заметки
=======

Взаимодействие объектов в Qt, сигналы и слоты, события устройств и системы, фильтр 
событий, интернационализация приложений (методы перевода)


1) Объектная модель Qt  
----------------------

__Qt содержит:__  
* механизм для непрерывного взаимодействия объектов, называемый «сигналы и слоты»;
* обработку и фильтрацию событий;
* список свойств виджетов или объектов для взаимодействия с другими виджетами и
объектами;
* удобный контекстный перевод строк для интернационализации;
* защищенные (умные) указатели;
* приведение типов;
* объектную иерархию.  

__Сигналы и слоты__ — это средства, позволяющие эффективно производить обмен информацией о 
событиях, вырабатываемых объектами. Когда наступает событие, объект генерирует сигнал, 
который поступает на слот другого объекта, соединенного с первым.
Механизм фильтрации событий позволяет их перехватывать.  
__Свойства__ — это поля, для которых обязательно должны существовать методы чтения. С их 
помощью можно получать доступ к атрибутам объектов извне, например при создании приложений 
на базе Qt Quick и реализации взаимодействия с объектами, написанными на C++.  
__Метаобъектная информация__ (`Q_PROPERTY`, `Q_OBJECT`, `Q_CLASSINFO`) включает в себя 
информацию о наследовании классов, что позволяет определять имя класса и наследственность 
от других классов.  
Многие из этих возможностей Qt реализованы с помощью стандартных приемов C++, базирующихся 
на наследовании от QObject. Остальным, подобно механизму связи между объектами и системе 
динамических свойств, требуется система метаобъектов, предоставляемая собственным 
компилятором метаобъектов (`moc`) Qt.


2) Управление памятью
---------------------
`(00.14.16)` - Умные указатели в Qt  

<pre><code>
#include <QSharedPointer>
    QSharedPointer<MyClass> obg(new MyClass());
//либо:
    obj = QSharedPointer<QObject>::create() //более безопасный вариант
</pre></code>
Также в любой момент можно выделить память под новый экземпляр объекта — удалить текущий, 
вызвав функцию 'reset'.
<pre><code>    obg.reset(new MyClass(this));</pre></code>

3) Сигналы и слоты
------------------
Слоты и сигналы объявляются в классе под соответствующими тегами:__slots__, __signals__.  
Сигналы и слоты могут содержать аргументы.  
Пример объявления:  
<pre><code>
signals:
    void signalExample1();
    void signalExample2(int);
    void signalExample3(bool);
    void signalExample4(int, QString);

private slots:
    void slotForSignalExample1();
    void slotForSignalExample2(int);
    void slotForSignalExample3(bool);
    void slotForSignalExample4(int, QString);
</pre></code>

__Слот__ — это функция, вызываемая в ответ на определенный сигнал. META-компилятор 
преобразует сигналы и слоты в функции API, используемой платформы. Сигнал же — результат событий 
действий пользователя, системных уведомлений (таймер, принятие данных на сокете и т. д).  

При генерации сигнала слоты, связанные с ним, исполняются немедленно, так же как и при 
обычном вызове функции. Когда это случается, механизм сигналов и слотов полностью независим 
от цикла обработки событий графического интерфейса пользователя. Выполнение кода, следующего 
за выражением `emit`, продолжится, __как только завершится выполнение всех слотов__. В 
случае с соединениями через очереди ситуация немного отличается: при этом исполнение кода, следующего 
за `emit`, продолжится немедленно, а слоты будут исполнены несколько позже.  

Если несколько слотов связаны с одним сигналом, то при испускании сигнала они будут 
выполнены __один за другим__ в том порядке, в котором они были соединены.  

Сигналы автоматически генерируются утилитой `moc`, и их не нужно включать в реализацию .cpp 
файлов. Они не должны иметь возвращаемых типов (т. е. объявляются как `void`).  

Слот вызывается, как только испускается соединенный с ним сигнал. Слоты это обычные функции 
C++, они могут вызываться обычным образом; их единственная особенность — то, что к ним могут 
быть присоединены сигналы.  

Сигнал, испускаемый объектом произвольного класса, может быть связан с закрытым (`private`) 
слотом и вызывать слот в совершенно постороннем классе.  

4) Соединение и разъединение объектов
-------------------------------------

Подключение осуществляется методом класса `QObject void connect(const QObject *sender, const 
char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)`. Данный 
метод принимает следующие аргументы:
* `const QObject *sender` — объект, генерирующий сигнал;
* `const char *signal` — с каким сигналом будет соединен слот. Нажатие кнопки генерирует два 
сигнала: `clicked()` и `clicked(bool)`;
* `const QObject *receiver` — сам объект, в котором расположен слот, и должен вызываться при 
генерации сигнала объекта __sender__;
* `const char *method` — имя слота, который будет вызываться;
* `Qt::ConnectionType type` — метод подключения (по умолчанию QT::AutoConnect).  

Полный список возможных значений: 
* `AutoConnection`, 
* `DirectConnection` (слот выполняется сразу после генерации сигнала), 
* `QueuedConnection` (слот выполняется в основном цикле получателя сигнала), 
* `BlockingQueuedConnection` (то же самое, что и QueuedConnection, но функция, которая 
сгенерировала сигнал, блокируется до окончания обработки слота), 
* `UniqueConnection` (флаг может использоваться с одним из предыдущих; он не 
позволяет создать дублирующее соединение для конкретной пары «сигнал/слот»: при попытке 
создать его метод connect возвращает код ошибки).  

Сигнал и слот указываются с помощью макросов __SIGNAL__, __SLOT__.  

Пример:
<pre><code>
connect(nextPicButton, SIGNAL(clicked()), this, SLOT(nextPicture())); 
connect(prevPicButton, SIGNAL(clicked()), this, SLOT(prevPicture()));

//еще вариант:
connect(this, &MainWindow::MySignal(int), this, &MainWindow::MySlot(int));
//позволяет ловить ошибки на этапе компилляции
</pre></code>

Для определения вызывающего сигнала используется функция `sender()`, возвращающая указатель 
на объект который послал сигнал:

<pre><code>qDebug() << sender()->objectName();</pre></code>

Для отсоединения в классе `QObject` есть метод `void disconnect(const QObject 
*sender, const char *signal, const QObject *reciever, const char *slot)`.  

__В случае подачи генерации сигнала, не подключенного к каким-либо слотам, никаких ошибок не 
генерируется.__   

5) Метаобъектный компилятор (__moc__)
-------------------------------------

Это программа, которая обрабатывает расширения C++ от Qt.  

Moc читает заголовочный файл C++. Если он находит одно или несколько объявлений классов, 
которые содержат макрос __Q_OBJECT__, то он порождает файл исходного кода C++, содержащий 
метаобъектный код для этих классов. Метаобъектный код требуется механизму сигналов и слотов, 
информации о типе времени выполнения и системы динамических свойств. Файл исходного кода 
C++, сгенерированный moc, должен компилироваться и компоноваться с помощью реализации 
класса.

![](https://fuzeservers.ru/wp-content/uploads/8/7/9/8790c2cd5ecf92b8deb6c42395a43608.jpeg)  

