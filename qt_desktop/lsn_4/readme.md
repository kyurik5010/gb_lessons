Заметки
=======

Взаимодействие объектов в Qt, сигналы и слоты, события устройств и системы, фильтр 
событий, интернационализация приложений (методы перевода)


1) Объектная модель Qt  
----------------------

__Qt содержит:__  
* механизм для непрерывного взаимодействия объектов, называемый «сигналы и слоты»;
* обработку и фильтрацию событий;
* список свойств виджетов или объектов для взаимодействия с другими виджетами и
объектами;
* удобный контекстный перевод строк для интернационализации;
* защищенные (умные) указатели;
* приведение типов;
* объектную иерархию.  

__Сигналы и слоты__ — это средства, позволяющие эффективно производить обмен информацией о 
событиях, вырабатываемых объектами. Когда наступает событие, объект генерирует сигнал, 
который поступает на слот другого объекта, соединенного с первым.
Механизм фильтрации событий позволяет их перехватывать.  
__Свойства__ — это поля, для которых обязательно должны существовать методы чтения. С их 
помощью можно получать доступ к атрибутам объектов извне, например при создании приложений 
на базе Qt Quick и реализации взаимодействия с объектами, написанными на C++.  
__Метаобъектная информация__ (`Q_PROPERTY`, `Q_OBJECT`, `Q_CLASSINFO`) включает в себя 
информацию о наследовании классов, что позволяет определять имя класса и наследственность 
от других классов.  
Многие из этих возможностей Qt реализованы с помощью стандартных приемов C++, базирующихся 
на наследовании от QObject. Остальным, подобно механизму связи между объектами и системе 
динамических свойств, требуется система метаобъектов, предоставляемая собственным 
компилятором метаобъектов (`moc`) Qt.


2) Управление памятью
---------------------
`(00.14.16)` - Умные указатели в Qt  

<pre><code>#include <QSharedPointer>
    
    QSharedPointer<MyClass> obg(new MyClass());
//либо:
    obj = QSharedPointer<QObject>::create() //более безопасный вариант
</pre></code>
Также в любой момент можно выделить память под новый экземпляр объекта — удалить текущий, 
вызвав функцию 'reset'.
<pre><code>    obj.reset(new MyClass(this));</pre></code>

3) Сигналы и слоты
------------------
Слоты и сигналы объявляются в классе под соответствующими тегами:__slots__, __signals__.  
Сигналы и слоты могут содержать аргументы.  
Пример объявления:  
<pre><code>
signals:
    void signalExample1();
    void signalExample2(int);
    void signalExample3(bool);
    void signalExample4(int, QString);

private slots:
    void slotForSignalExample1();
    void slotForSignalExample2(int);
    void slotForSignalExample3(bool);
    void slotForSignalExample4(int, QString);
</pre></code>

__Слот__ — это функция, вызываемая в ответ на определенный сигнал. META-компилятор 
преобразует сигналы и слоты в функции API, используемой платформы. Сигнал же — результат событий 
действий пользователя, системных уведомлений (таймер, принятие данных на сокете и т. д).  

При генерации сигнала слоты, связанные с ним, исполняются немедленно, так же как и при 
обычном вызове функции. Когда это случается, механизм сигналов и слотов полностью независим 
от цикла обработки событий графического интерфейса пользователя. Выполнение кода, следующего 
за выражением `emit`, продолжится, __как только завершится выполнение всех слотов__. В 
случае с соединениями через очереди ситуация немного отличается: при этом исполнение кода, следующего 
за `emit`, продолжится немедленно, а слоты будут исполнены несколько позже.  

Если несколько слотов связаны с одним сигналом, то при испускании сигнала они будут 
выполнены __один за другим__ в том порядке, в котором они были соединены.  

Сигналы автоматически генерируются утилитой `moc`, и их не нужно включать в реализацию .cpp 
файлов. Они не должны иметь возвращаемых типов (т. е. объявляются как `void`).  

Слот вызывается, как только испускается соединенный с ним сигнал. Слоты это обычные функции 
C++, они могут вызываться обычным образом; их единственная особенность — то, что к ним могут 
быть присоединены сигналы.  

Сигнал, испускаемый объектом произвольного класса, может быть связан с закрытым (`private`) 
слотом и вызывать слот в совершенно постороннем классе.  

4) Соединение и разъединение объектов
-------------------------------------

Подключение осуществляется методом класса `QObject void connect(const QObject *sender, const 
char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)`. Данный 
метод принимает следующие аргументы:
* `const QObject *sender` — объект, генерирующий сигнал;
* `const char *signal` — с каким сигналом будет соединен слот. Нажатие кнопки генерирует два 
сигнала: `clicked()` и `clicked(bool)`;
* `const QObject *receiver` — сам объект, в котором расположен слот, и должен вызываться при 
генерации сигнала объекта __sender__;
* `const char *method` — имя слота, который будет вызываться;
* `Qt::ConnectionType type` — метод подключения (по умолчанию QT::AutoConnect).  

Полный список возможных значений: 
* `AutoConnection`, 
* `DirectConnection` (слот выполняется сразу после генерации сигнала), 
* `QueuedConnection` (слот выполняется в основном цикле получателя сигнала), 
* `BlockingQueuedConnection` (то же самое, что и QueuedConnection, но функция, которая 
сгенерировала сигнал, блокируется до окончания обработки слота), 
* `UniqueConnection` (флаг может использоваться с одним из предыдущих; он не 
позволяет создать дублирующее соединение для конкретной пары «сигнал/слот»: при попытке 
создать его метод connect возвращает код ошибки).  

Сигнал и слот указываются с помощью макросов __SIGNAL__, __SLOT__.  

Пример:
<pre><code>
connect(nextPicButton, SIGNAL(clicked()), this, SLOT(nextPicture())); 
connect(prevPicButton, SIGNAL(clicked()), this, SLOT(prevPicture()));

//еще вариант:
connect(this, &MainWindow::MySignal(int), this, &MainWindow::MySlot(int));
//позволяет ловить ошибки на этапе компиляции
</pre></code>

Для определения вызывающего сигнала используется функция `sender()`, возвращающая указатель 
на объект который послал сигнал:

<pre><code>qDebug() << sender()->objectName();</pre></code>

Для отсоединения в классе `QObject` есть метод `void disconnect(const QObject 
*sender, const char *signal, const QObject *reciever, const char *slot)`.  

__В случае подачи генерации сигнала, не подключенного к каким-либо слотам, никаких ошибок не 
генерируется.__   

5) Метаобъектный компилятор (__moc__)
-------------------------------------

Это программа, которая обрабатывает расширения C++ от Qt.  

Moc читает заголовочный файл C++. Если он находит одно или несколько объявлений классов, 
которые содержат макрос __Q_OBJECT__, то он порождает файл исходного кода C++, содержащий 
метаобъектный код для этих классов. Метаобъектный код требуется механизму сигналов и слотов, 
информации о типе времени выполнения и системы динамических свойств. Файл исходного кода 
C++, сгенерированный moc, должен компилироваться и компоноваться с помощью реализации 
класса.

![](https://fuzeservers.ru/wp-content/uploads/8/7/9/8790c2cd5ecf92b8deb6c42395a43608.jpeg)  

__6) Пример кода с прописанными кнопками и привязкой к слотам__  
---------------------------------------------------------------
`1.32.00`  
<pre><code>
#include <QPushButton>
QPushButton *nextPicButton, *prevPicButton;
nextPicButton = new QPushButton(this);
prevPicButton = new QPushButton(this);
nextPicButton->move(695, 600 - 30); // перемещение по x y
prevPicButton->move(5, 600 - 30);
nextPicButton->setText("Следующия"); 
prevPicButton->setText("Предыдущая");
connect(nextPicButton, SIGNAL(clicked()), this, SLOT(nextPicture())); 
connect(prevPicButton, SIGNAL(clicked()), this, SLOT(prevPicture()));
</pre></code>

__7) Обработка событий__
------------------------

<pre><code>
include <QMouseEvent>
include <QKeyEvent>
protected:
    void mousePressEvent(QMouseEvent *event) override;
    void mouseReleaseEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;

    void keyPressEvent(QKeyEvent *event) override;
    void keyReleaseEvent(QKeyEvent *event) override;

    int posCursor;

void Mainwindow::keyReleaseEvent(QMouseEvent *event)
{
    if(event->ley() == Qt::Key_Left)
    {
        qDebug() << "left key pressed";
    }
}

void Mainwindow::mousePressEvent(QMouseEvent *event)
{
    posCursor = event->x();
}

void Mainwindow::mouseReleaseEvent(QMouseEvent *event)
{
    int x = event->x();
    if(x > posCursor)
    {
        qDebug() << "move right";
    }
    else if(x < posCursor)
    {
        qDebug() << "move left";
    }
}
</pre></code>

8) Фильтры событий
------------------

	Иногда возникает необходимость перехватить событие другого объекта. Например, диалоговым 
окнам обычно необходимо фильтровать нажатия клавиш для некоторых виджетов, например для 
изменения поведения клавиши Отмена.  
	Функция `QObject::installEventFilter()` предоставляет возможность реализации такого фильтра. 
Также фильтр можно легко отключить, используя метод `QObject::removeEventFilter()`.

8) Перевод приложения
---------------------

`1.58.26`  

	Для реализации перевода программы в Qt нужно, чтобы все строки программы при использовании 
предварительно передавались в метод `tr`, т.е. вместо кода `QString text = “Hello”;` нужно 
использовать: `QString text = tr(“Hello”)`.  

	Помимо прочего, в файл __pro__ необходимо добавить следующие строки:
<pre><code>
TRANSLATIONS += QtLanguage_ru.ts QtLanguage_ja.ts 
CODECFORSRC = UTF-8
</pre></code>

	С помощью консоли или терминала компилятора перейдем к рабочему каталогу проекта и вводим 
команду `lupdate *.pro`.
	Перейдем к переводу текста с помощью программы Qt Linquist, которая входит в пакет установки 
фреймворка Qt.  
	В нижней части экрана осуществляется сам перевод, а также размещается поле для комментария к 
переводу. После введения перевода сохраняем изменения. Когда перевод окончен, __нажимаем на 
вопросительный знак__ напротив исходного текста, сообщая о завершении перевода. Далее в меню 
__Файл__ выбираем __Скомпилировать__. В каталоге проекта появятся файлы переводов с 
расширением __qm__.  
	Копируем эти файлы в теневой каталог сборки. Следующим шагом необходимо __загрузить__ файл перевода с помощью методов класса `QTranslater` и `QApplication`. Это методы загрузки файла 
локализации и установки текущего перевода программы.
<pre><code>
int main(int argc, char *argv[]) {
QApplication a(argc, argv);
QTranslator translator;
translator.load("./QtLanguage_" + QLocale::system().name()); 
//translator.load("./QtLanguage_ja"); // переключить на японский 
a.installTranslator(&translator); QResource::registerResource("./resmy.rcc");
MainWindow w;
w.resize(800, 600); // сделаем окно больше w.show();
return a.exec();
}
</pre></code>  

	Статический метод `system()` класса __QLocale__ представляет информацию о текущем языке ОС.  


10) Обращение к командной строке из программы
---------------------------------------------

	Программа может выполнять команды терминала ОС. Такие действия, как копирование и 
перемещение, можно выполнить стандартной командой __cmd__ или __POSIX__.  
<pre><code>
system("calc");               // Запуск калькулятора в ОС Windows 
system("sudo reboot");        // Перезагрузить ПК ОС семейства Linux 
system("gcc main.c -o soft"); // Скомпилировать проект на языке Си
                              // в UNIX-подобной ОС
</pre></code>  

	Другой вариант — использовать класс __QProcess__. Он позволяет получать сообщения, 
которые выводятся в консоли. У объекта `QProcess` есть интересный сигнал 
`readyReadStandardOutput`, который генерируется при получении сообщения.
<pre><code>
//в заголовочном
private slots:
    void on_pushButton_clicked(); void procCMD();

private:
    QProcess *proc;

//в конструкторе реализуемого класса:
	proc = new QProcess(this);
	connect(proc, SIGNAL(readyReadStandardOutput()), this, SLOT(procCMD()));
}

void MainWindow::on_pushButton_clicked() 
{
    QString cmd = "";
    if (QSysInfo::productType() == "windows") 
    {
         cmd = "cmd /C "; 
    }
    cmd += ui->lineEdit->text();
    proc->start(cmd); 

}
void MainWindow::procCMD() 
{
    QTextCodec *codec = QTextCodec::codecForName("IBM866");
    ui->plainTextEdit->appendPlainText(codec->toUnicode(proc->readAllStandardOutput( )));
}
</pre></code>

Дополнительные материалы
------------------------
1. http://doc.crossplatform.ru/qt/4.5.0/signalsandslots.html.
2. https://doc.qt.io/qt-5/qobject.html#installEventFilter.
3. https://doc.qt.io/qt-5/eventsandfilters.html.
4. Qaru: 
http://qaru.site/questions/1262729/my-qt-eventfilter-doesnt-stop-events-as-it-should.

